"""
x - input signal of real numbers
discreteMin - locations of discrete minima
discreteMax - locations of discrete maxima

When running the EMD, the discrete extrema for this function will actually be the extrema generated by the interpolation
function.
"""

import numpy as np

def extrap(x, discreteMin, discreteMax):
    """
    produces two ghost cells on both side of the signal that contain a min and max
    value equal to the first min and max of the signal and the last min and max of
    the signal in order to better extrapolate the first and last points of the signal
    """

    if len(discreteMax) > 0:
        if x[0] >= discreteMax[0, 1]:
            # print('first point is maximum')
            discreteMax = np.flip(discreteMax, 0)
            discreteMax = np.append(discreteMax, [[0, x[0]]], axis=0)
            discreteMax = np.flip(discreteMax, 0)
        if x[-1] >= discreteMax[-1, 1]:
            # print('end point is maximum')
            discreteMax = np.append(discreteMax, [[len(x) - 1, x[-1]]], axis=0)

    if len(discreteMin) > 0:
        if x[0] <= discreteMin[0, 1]:
            # print('first point is minimum')
            discreteMin = np.flip(discreteMin, 0)
            discreteMin = np.append(discreteMin, [[0, x[0]]], axis=0)
            discreteMin = np.flip(discreteMin, 0)
            # print(discreteMin)
        if x[-1] <= discreteMin[-1, 1]:
            # print('end point is maximum')
            discreteMin = np.append(discreteMin, [[len(x) - 1, x[-1]]], axis=0)

            # extrapolating beginning of signal

    if discreteMin[0, 0] == 0 and discreteMax[0, 0] == 0:
        print("First point is both a min or max!")  # IMF is zero at the ends
    else:
        reflectedMin = [-discreteMax[0, 0], discreteMin[0, 1]]
        discreteMin = np.flip(discreteMin, 0)
        discreteMin = np.append(discreteMin, [reflectedMin], axis=0)
        discreteMin = np.flip(discreteMin, 0)

        reflectedMax = [-discreteMin[1, 0], discreteMax[0, 1]]
        discreteMax = np.flip(discreteMax, 0)
        discreteMax = np.append(discreteMax, [reflectedMax], axis=0)
        discreteMax = np.flip(discreteMax, 0)

    # extrapolating end of signal
    if discreteMin[-1, 0] == len(x) - 1 and discreteMax[-1, 0] == len(x) - 1:
        print("First point is both a min or max!")  # IMF is zero at the ends
    else:
        discreteMin = np.append(discreteMin, [[2 * (len(x) - 1) - discreteMax[-1, 0], discreteMin[-1, 1]]], axis=0)
        discreteMax = np.append(discreteMax, [[2 * (len(x) - 1) - discreteMin[-2, 0], discreteMax[-1, 1]]], axis=0)

    return (discreteMin, discreteMax)
