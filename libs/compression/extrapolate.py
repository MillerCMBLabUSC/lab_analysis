"""
x - input signal of real numbers
discreteMin - locations of discrete minima
discreteMax - locations of discrete maxima

When running the EMD, the discrete extrema for this function will actually be the extrema generated by the interpolation
function.
"""

import numpy as np
import math 
def extrap(x, discreteMin, discreteMax):
    """
    produces two ghost cells on both side of the signal that contain a min and max
    value equal to the first min and max of the signal and the last min and max of
    the signal in order to better extrapolate the first and last points of the signal
    """
    #intially we say that the first point of the signal is not an extrema, then we check
    begin_max = False
    begin_min = False
    end_max = False
    end_min = False
   
    dMin = discreteMin
    dMax = discreteMax
    if len(discreteMin) == 0 and len(discreteMax) == 0:
        return (discreteMin, discreteMax)
    
    if len(discreteMin) == 0 or len(discreteMax) == 0:
        return (discreteMin,discreteMax)
    if len(discreteMax) > 0: #otherwise, create ghost point with first maximum
        reflectedMin = [-discreteMax[0, 0], discreteMin[0, 1]]
        discreteMin = np.flip(discreteMin, 0)
        discreteMin = np.append(discreteMin, [reflectedMin], axis=0)
        discreteMin = np.flip(discreteMin, 0)
    if len(discreteMin) > 0:
        reflectedMax = [-discreteMin[1, 0], discreteMax[0, 1]]
        discreteMax = np.flip(discreteMax, 0)
        discreteMax = np.append(discreteMax, [reflectedMax], axis=0)
        discreteMax = np.flip(discreteMax, 0)
    if len(discreteMin) <= 1 or len(discreteMax) <= 1:
        return (discreteMin,discreteMax)

     
    
    discreteMin = np.append(discreteMin, [[2 * (len(x) - 1) - discreteMax[-1,0], discreteMin[-1,1]]], axis = 0) 
    discreteMax = np.append(discreteMax, [[2 * (len(x) - 1) - discreteMin[-2, 0], discreteMax[-1, 1]]], axis=0)
     
       
    discreteMin = discreteMin[np.argsort(discreteMin[:,0])]
    discreteMax = discreteMax[np.argsort(discreteMax[:,0])]
    
    return (discreteMin, discreteMax)

if __name__ == '__main__':
    import discreteMinMax
    import interpolate
    #noise = open('69.txt','r').read().split('\n')[0:100]
    #noise = [float(i) for i in noise]
    import simulate
    import math
    alpha = 1.0
    white_noise_sigma = 3/math.sqrt(12)
    length_ts = 60
    f_knee = 2.0
    sample_rate = 100.0
    noise = simulate.simulate_noise(alpha, white_noise_sigma,length_ts, f_knee, sample_rate)
    [discreteMin,discreteMax] = discreteMinMax.discreteMinMax(noise)
    #[parabolicMin,parabolicMax] = interpolate.interp(noise,discreteMin,discreteMax)
    [parabolicMin,parabolicMax] = extrap(noise,discreteMin,discreteMax)
    print(noise)
    print(parabolicMin)
    print(parabolicMax)
        
