import numpy as np
import scipy.integrate as intg
import opticalElement as opel

#Physical Constants
#Everything is in MKS units
#Planck constant [J/s]
h = 6.6261e-34
#Boltzmann constant [J/K]
kB = 1.3806e-23
#Speed of light [m/s]
c = 299792458.0
#Pi
PI = 3.14159265

#Calculates total black body power for a given temp and emis.
def weightedSpec(freq,temp,emis):
	occ = 1.0/(np.exp(h*freq/(temp*kB)) - 1)
	AOmega = (c/freq)**2
	return (AOmega*(2*emis*h*freq**3)/(c**2)* occ)


def bbPower(temp, emis, f1,f2):
	power = .5*intg.quad(lambda x: weightedSpec(x,temp,emis), f1, f2)[0]
	return power




##Calculates upper and lower frequencies. 
## This data should actually be read from a channel.txt file
GHz = 1.e9
ch_freqs = np.array([27.0,39.0,93.0,145.0,233.0,225.0,278.0])*GHz
ch_fbw = np.array([.222,.462,.376,.276,.322,.267,.162])
ch_num = -1;

freq1 = ch_freqs[ch_num] - (ch_freqs[ch_num]*ch_fbw[ch_num])/2
freq2 = ch_freqs[ch_num] + (ch_freqs[ch_num]*ch_fbw[ch_num])/2

#Input files
optChainFile = "opticalChain.txt"
atmFile = "Atacama_1000um_60deg.txt"

##Data to calculate power coming from the CMB and the atmosphere
##############
skyNames = []
skyTemps = []
skyEffs = []
skyEmis = []

#CMB data
skyNames.append("CMB")
skyTemps.append(2.725) #K
skyEffs.append(1)	#CMB Efficiency doesn't really matter since incoming power is 0
skyEmis.append(1)	#Perfect Blackbody

#Atm data
skyNames.append("Atmos")
skyTemps.append(273.) #K

#Calculating the sky efficiency
fs, ts = np.loadtxt(atmFile, dtype=np.float, unpack=True, usecols=[0, 3])
fs*=GHz
freqs = []
effs = []

for i in range(len(fs)):
	if fs[i] > freq1 and fs[i] < freq2:
		freqs.append(fs[i])
		effs.append(ts[i])

## For the transmission coefficient, we simply use the average transmission coefficient in the desired frequency range.
atmEff = np.trapz(effs, freqs)/(freqs[-1] - freqs[0])
skyEffs.append(atmEff)
# The emission (or absorption) is 1 - efficiency. 
skyEmis.append(1- atmEff)

## It is also possible to calculate the temp, emissivity and efficiency of the synchrotron and dust.
## This calculation is harder, but is done in Charlie's code.



d = np.loadtxt(optChainFile, dtype = np.str)

#Initializes each optical element
elems = []
for i in range(1, len(d)-1):
	elems.append(opel.OpticalElement(d[i]))



incPowers = [0]
outPowers = []
# The power incident on element i is 
# power on element i-1 * efficiency of element i-1 + power generated by i-1
for i in range(len(skyNames)):
	p =  bbPower(skyTemps[i], skyEmis[i],freq1,freq2)
	outPowers.append(p)
	incPowers.append(incPowers[-1]*skyEffs[i] + p)

for i in range(len(elems)):
	p = bbPower(elems[i].temp, elems[i].emis,freq1,freq2)
	outPowers.append(p)
	incPowers.append(incPowers[-1]*elems[i].eff + p)

print "freq: %.2f GHz"%(ch_freqs[ch_num]/GHz)
print "Name\t\t\tOutput power(W)\t\tIn power(W)"
print "-"*50
for i in range(len(skyNames)):
	print "%8s\t\t%e\t\t%e"%(skyNames[i], outPowers[i],incPowers[i])
print "- "* 30
for i in range(len(elems)):
	print "%8s\t\t%e\t\t%e"%(elems[i].name, outPowers[i + len(skyNames)], incPowers[i + len(skyNames)])









