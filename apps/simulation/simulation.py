#! /usr/bin/python

import numpy as np
import pylab as pl
import matplotlib.pyplot as plt
import matplotlib.cm as cm
import healpy
import scipy
from scipy import signal
from lab_analysis.libs.geometry import coordinates
from lab_analysis.apps.simulation import default_settings
from lab_analysis.apps.simulation import new_pointing
from lab_analysis.apps.simulation import test_pointing
from lab_analysis.libs.units.angles import *
#from lab_analysis.libs.noise import simulate


#class Simulator(lab_app.App):
class Simulator(object):
	'''
	Class: Simulator
	
	Purpose: set of functions to simulate the data processing pipeline for observing the
		polarization of the CMB using a half wave plate (HWP)
	
	Functions:
	-> run
	-> run_one_bolo
	-> rotate_boresight_pointing
	-> add_nonlinearity
	-> add_noise
	-> hwp_rotation
	-> add_hwpss
	-> plot_data
	-> make_map
	
	'''
	
	def run(self):
		'''
		Function: run
		
		Purpose: serves as the main function of the simulation. The run function takes care
			of all of the other steps.
		
		Inputs: none
		
		Outputs: a pyplot figure containing the timestream (signal vs time) 
		
		'''
		
		self.settings = default_settings.SimulatorSettings()
		self.create_pointing = new_pointing.CreatePointing()
		self.num_data_pts = 2650
		times = np.linspace(0., self.settings.t_end, num = self.num_data_pts)
		
		if self.settings.conduct_test:
		#if I want to conduct a test and scan the galactic center, I would generate a test
		#pointing, write coordinates and times to file, and annotate the graph with relevant
		#values. Otherwise, I would proceed as usual.
			boresight_pointing = test_pointing.use_test_pointing(times)
			test_pointing.write_coords_to_file(times, boresight_pointing)
		if not self.settings.conduct_test:
		#if I'm not conducting a test, I am proceeding with the usual scan strategy
			boresight_pointing = self.create_pointing.make_boresight_pointing()
			times = np.linspace(0., self.settings.t_end, num = int(self.create_pointing.num_data_points))
		
		maps = healpy.read_map((self.settings.map_filename), field = (0, 1, 2))
		for bolo in range(0, self.settings.num_bolos):
			self.run_one_bolo(bolo, boresight_pointing, maps, times)
		plt.show()
	
	
	def run_one_bolo(self, bolo, boresight_pointing, maps, times):
		'''
		Function: run_one_bolo
		
		Purpose: runs simulation for one bolometer at a time, in the event that multiple bolos are
			used. The number of bolos can be accessed/changed in default_settings. 
		
		This function: 	* uses the boresight pointing (generated by new_pointing file)
				* rotates it according to the number of bolos
				* converts to lat/lon
				* reads healpy map and gets corresponding I, Q, and U values
				* demodulates the signal
				* adds noise/non-linearity/HWPSS 
				* plots the signal
				* can also make and write a healpy map if developed further.
		
		Inputs:
		-> bolo (int): bolometer number
		-> boresight_pointing (float): array of coordinates in ra/dec
		-> maps (healpy map): map being used. This can be accessed/changed in default_settings.
		-> times (float): array of times
		
		Outputs: none
		
		'''
		
		detector_pointing = self.rotate_boresight_pointing(boresight_pointing, bolo)
		lat, lon = coordinates.eq_to_gal(detector_pointing[0], detector_pointing[1])
		bolo_i = healpy.get_interp_val(maps[0], pl.pi/2.0-lat, lon)
		bolo_q = healpy.get_interp_val(maps[1], pl.pi/2.0-lat, lon)
		bolo_u = healpy.get_interp_val(maps[2], pl.pi/2.0-lat, lon)
		bolo_alpha = 1/2. * pl.arctan2(bolo_u, bolo_q)
		bolo_p = pl.sqrt(bolo_q**2 + bolo_u**2)/bolo_i
		#hwp_angle = np.sin(2*pl.pi * self.settings.f_hwp * self.hwp_angles)
		#hwp_angle = 2*pl.pi * self.settings.f_hwp * self.hwp_rotation()
		data = 1/2.* (bolo_i + bolo_p * pl.cos(4*self.hwp_rotation() - 2*bolo_alpha))
		data = self.add_hwpss(times, data, self.hwp_rotation())
		#data = self.add_nonlinearity(data)
		#data = self.add_noise(data, self.settings.add_white_noise, self.settings.add_1f_noise)
		self.plot_data(times, data)
		#self.make_map(data, lat, lon)
		
	
	def rotate_boresight_pointing(self, pointing, bolo_number):
		'''	
		Function: rotate_boresight_pointing
		
		Purpose: rotates the array of coordinates depending on the number/arrangement of bolos. It is
			a little clunky at the moment.

		Inputs:
		-> pointing (float): array of coordinates generated using pointing strategy
						(whether test_pointing or new_pointing) in lats/lons
		-> bolo_number (int): bolometer number
		
		Outputs:
		-> pointing (float): rotated pointing 
		
		'''
		
		pointing = list(pointing)
		if self.settings.num_bolos == 1:
			#using 1 bolo returns the boresight pointing
			return pointing
		elif self.settings.num_bolos == 2:
			#2 bolos are arranged 0.005 (~50m) apart
			if bolo_number == 0:
				pointing[0] -= 0.0025
			elif bolo_number == 1:
				pointing[0] += 0.0025
		elif self.settings.num_bolos == 3:
			#3 bolos are arranged in triangle with base 0.005 (~50m) and height 0.005 (~50m)
			if bolo_number == 0:
				pointing[1] += 0.0025
			elif bolo_number == 1:
				pointing[0] += 0.0025
				pointing[1] -= 0.0025
			elif bolo_number == 2:
				pointing[0] -= 0.0025
				pointing[1] -= 0.0025
		pointing = tuple(pointing)
		
		return pointing
	
	
	def add_nonlinearity(self, signal, signal_min=-0.2):
		'''
		Function: add_nonlinearity
		
		Purpose: adds element of non-linearity to signal. I just found this in the LEAP code and am using it.

		Inputs: 
		-> signal (float): input signal array
		-> signal_min (float): ?? default is -0.2
		
		Outputs:
		-> compressed_signal + signal_min (float): output array of signal with non-linearity
		
		'''
		
		signal -= signal_min
		compressed_signal = signal - 0.04*signal**2 + 0.001*signal**3
		return compressed_signal + signal_min
	
		
#	def add_noise(self, signal, alpha = 1.0, f_knee = 0.1, add_white_noise = False, add_1f_noise = False):
		'''
		Function: add_noise
		
		Purpose: adds noise to input signal. Can add white noise, 1/f noise, both, or neither.
		
		Inputs:
		-> signal (float): input signal array
		-> alpha (float): alpha parameter for 1/f noise
		-> f_knee (float): f_knee parameter for 1/f noise
		-> add_white_noise (bool): whether or not to add white noise (can be changed in default_settings)
		-> add_1/f_noise (bool): whether or not to add 1/f noise (can be changed in default_settings)
		
		Outputs:
		-> signal + white_noise + 1f_noise (float): output signal array with noise added
		
		Notes:
		-> This is incomplete, hence why it's completely commented out. This was derived from the 
			LEAP files that simulated noise. It is unclear what the "frequencies" parameter in the
			1/f noise portion refers to and needs further work.
		
		'''
		
#		if add_white_noise:
#			white_noise_sigma = self.settings.NET / pl.sqrt(self.settings.dt)
#			white_noise = simulate.simulate_noise(alpha, white_noise_sigma, signal.size, f_knee, self.settings.dt)
#		else:
#			white_noise = np.zeros
#		
#		if add_1f_noise:
#			1f_noise = one_over_f(frequencies, alpha, f_knee)
#		else:
#			1f_noise = np.zeros
#		
#		return signal + white_noise + 1f_noise	
	
	
	def hwp_rotation(self):
		'''
		Function: hwp_rotation
		
		Purpose: generates an array of angles for the rotation of the half-wave plate at a
			frequency of 2Hz (in our case, at least)
		
		Inputs: none
		
		Outputs:
		-> hwp_angle_array (float): array of angles
		
		'''
		
		period_length = self.settings.f_data/self.settings.f_hwp
		period = np.linspace(0., 2*pl.pi, num = period_length)
		hwp_angle_array = np.resize(period, int(self.num_data_pts))
		return hwp_angle_array
	
	def add_hwpss(self, times, signal, hwp_angle):
		'''
		Function: add_hwpss
		
		Purpose: adds the half-wave plate synchronous signal to the input signal. We are using the
			following approximation:
				A1 = 50mK
				A2 = 100mK
				A4 = 200mK
				All other coeffs = 0
		
		Inputs:
		-> times (float): array of times
		-> signal (float): input signal array
		-> hwp_angle (float): array of hwp angles
		
		Outputs:
		-> signal + hwpss (float): output signal array with the added hwp synchronous signal
		
		'''
		
		#approximation we are using for now: A1 = 50mK, A2 = 100, A4 = 200. All other coeffs = 0.
		hwpss = 0.05*pl.cos(hwp_angle) + 0.1*pl.cos(2*hwp_angle) + 0.2*pl.cos(4*hwp_angle)
		return signal + hwpss
	
	def plot_data(self, times, data_to_plot):
		'''
		Function: plot_data
		
		Purpose: plots the timestream and displays a charge of Time vs Signal. If the conduct_test
			parameter in default_settings is set to True, it will also display the annotated local
			minima and maxima.
		
		Inputs:
		-> times (float): array of times
		-> data_to_plot (float): signal array to plot
		
		Outputs: displays a chart
		
		'''
		
		plt.axhline(linewidth = 0.5, color = 'k')
		plt.plot(times, data_to_plot, markersize = 1.5)
		#plt.plot(times, data_to_plot,'.', markersize = 1.5)
		if self.settings.conduct_test:
			test_pointing.print_local_min_max(data_to_plot, 0.00000001, x = times)
		plt.xlabel('Time (s)')
		plt.ylabel('K_cmb')
		plt.title(self.settings.map_name)
	
	def make_map(self, data, lat, lon):
		'''
		Function: make_map
		
		Purpose: writes data to a Healpy map. This is incomplete and currently does not work.
		
		Inputs:
		-> data (float): signal array
		-> lat (float): galactic latitude array
		-> lon (float): galactic longitude array
		
		Outputs: none
		 
		'''
		
		nside = 1024
		npix = healpy.nside2npix(nside)
		indices = healpy.ang2pix(nside, lon, lat, lonlat = True)
		hpmap = np.zeros(npix, dtype = np.float)
		hpmap[indices] += data[indices]
		healpy.mollview(hpmap)
		
	

if __name__ == "__main__":
	simulator = Simulator()
	simulator.run()
	#simulator.end()
